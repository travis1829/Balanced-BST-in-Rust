/* A struct that stores pointers to nodes
and can be sent to other threads. */
struct Cursor<K, V> {
    ptr: *mut Node<K, V>,
}
unsafe impl<K, V> Send for Cursor<K, V> {}
unsafe impl<K, V> Sync for Cursor<K, V> {}

impl<K, V> Cursor<K, V> {
    fn new(ptr: *mut Node<K, V>) -> Self {
        Cursor {
            ptr,
        }
    }
}
/*
impl<K, V> Clone for Cursor<K, V> {
    fn clone(&self) -> Self {
        Cursor(self.0.clone())
    }
}
*/

    //assumes node is non-null
    unsafe fn _rebuild(&self, node: &mut *mut Node<K, V>) {
        //Create an empty array
        let mut vector : Vec<Cursor<K, V>> = Vec::with_capacity((**node).size);
        vector.set_len((**node).size);
        let mut array = vector.into_boxed_slice();

        //Rebuild the tree using the array
        self._into_array(Cursor::new(*node), &mut array[..]);
        *node = self._into_tree(&array[..]);
    }

    //assumes node is non-null
    unsafe fn _into_array(&self, cursor: Cursor<K, V>, array: &mut [Cursor<K, V>]) {
        /* Use crossbeam's scoped thread, because before this function ends, 
        we will always join with the thread created in this function. */
        thread::scope(|s| {
            let mut index = 0;

            //1. Process the left subtree, using a new thread if the subtree is big
            let wrapped_handler = 
            if (*cursor.ptr).left != ptr::null_mut() {
                let lcursor = Cursor::new((*cursor.ptr).left);
                index = (*lcursor.ptr).size;
                if index < THREAD_SPAWNING_SIZE {
                    self._into_array(lcursor, &mut array[..index]);
                    None
                }
                else {
                    let larray = slice::from_raw_parts_mut(array.as_mut_ptr(), index);
                    Some(s.spawn(move |_| {
                        self._into_array(lcursor, larray);
                    }))
                }
            }
            else {
                None
            };

            //2. Process the right subtree in this thread
            if (*cursor.ptr).right != ptr::null_mut() {
                let rcursor = Cursor::new((*cursor.ptr).right);
                self._into_array(rcursor, &mut array[index+1..]);
            }

            //3. Finish by writing at the array and joining with the thread (if exists)
            array[index] = cursor;
            if let Some(handler) = wrapped_handler {
                handler.join().unwrap();
            }
        }).unwrap();
    }

    fn _into_tree(&self, array: &[Cursor<K, V>]) -> *mut Node<K, V> {
        let size = array.len();
        if size == 0 {  //Empty
            ptr::null_mut()
        }
        else if size/2 < THREAD_SPAWNING_SIZE { //Small enough to be processed by a single thread
            unsafe {
                let node = array[size/2].ptr;
                (*node).left = self._into_tree(&array[..size/2]);
                (*node).right = self._into_tree(&array[size/2+1..]);
                (*node).size = size;
                node
            }
        }
        else {  //Process using multiple threads
            unsafe {
                thread::scope(|s| {
                    //1. Process the left part in a new thread
                    let larray = slice::from_raw_parts(array.as_ptr(), size/2);
                    let lhandler = s.spawn(move |_| {
                        Cursor::new(self._into_tree(larray))
                    });

                    //2. Process the right part in this thread
                    let node = array[size/2].ptr;
                    (*node).size = size;
                    (*node).right = self._into_tree(&array[size/2+1..]);

                    //3. Join with the thread
                    (*node).left = lhandler.join().unwrap().ptr;
                    node
                }).unwrap()
            }
        }
    }